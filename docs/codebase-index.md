# Codebase Index

> **Note**: This semantic index is a temporary solution. It will be replaced with a vector-based index in the future for improved semantic search and context retrieval.

## Overview

The codebase index is a machine-readable JSON file that maps repository file paths to LLM-generated descriptions. It provides a quick overview of your project's structure and purpose, enabling AI coding agents to understand your codebase without reading every file.

**Location**: `.bluprint/codebase/semantic_index.json`

## Purpose

The index serves as:

- **Project documentation** for AI agents to quickly understand file purposes
- **Context provider** for code generation and analysis tasks
- **Navigation aid** to help agents find relevant files
- **Interim solution** until vector-based semantic search is implemented

## Structure

```json
{
  "generatedAt": "2025-12-11T05:48:21.710Z",
  "files": [
    {
      "path": "src/agent/agents/codeSummarizer.ts",
      "description": "Creates a code summarizer agent that generates concise file descriptions using a language model."
    }
  ]
}
```

### Fields

- **generatedAt**: ISO 8601 timestamp of when the index was generated
- **files**: Array of file entries
  - **path**: Repository-relative file path
  - **description**: Concise (~200 characters) LLM-generated description of the file's purpose

## Generation

The index is generated by the `bluprint index` command:

```bash
# Index entire repository
bluprint index

# Index specific directory
bluprint index src

# Output JSON to stdout
bluprint index --json
```

### Process

1. **File Discovery**: Uses `git ls-files` to find tracked files, automatically respecting `.gitignore`
2. **Binary Filtering**: Excludes 75+ binary file extensions (images, videos, archives, executables, etc.)
3. **Description Generation**: LLM analyzes each file and generates a concise description
4. **Rate Limiting**: Files processed sequentially with delays to avoid API throttling
5. **Persistence**: Writes index to `.bluprint/codebase/semantic_index.json`

## Excluded File Types

Binary and non-text files are automatically excluded to prevent LLM errors and reduce token usage:

- **Images**: jpg, png, gif, svg, webp, etc.
- **Video**: mp4, avi, mov, mkv, etc.
- **Audio**: mp3, wav, flac, aac, etc.
- **Documents**: pdf, docx, xlsx, pptx, etc.
- **Archives**: zip, rar, 7z, tar, gz, etc.
- **Executables**: exe, dll, bin, wasm, etc.
- **Databases**: db, sqlite, mdb, etc.
- **Fonts**: ttf, woff, otf, etc.

See `HARD_EXCLUDED_EXTENSIONS` in `src/lib/codebase/discover.ts` for the complete list.

## Description Characteristics

- **Length**: Capped at 200 characters for efficiency
- **Content**: Focus on primary purpose, key exports, and responsibilities
- **Format**: Trimmed of leading/trailing whitespace
- **Quality**: Generated by LLM with specialized prompt for conciseness

## Usage Patterns

### Initial Setup

After running `bluprint init`, generate your first index:

```bash
bluprint index
```

### Incremental Updates

Re-run the index command after significant code changes:

```bash
# Update full index
bluprint index

# Update specific module
bluprint index src/agent
```

### Integration with Agents

The index can be loaded programmatically:

```typescript
import { workspaceCodebase } from './lib/workspace/codebase.js';

const result = await workspaceCodebase.loadCodebaseIndex();
if (result.isOk()) {
  const index = result.value;
  // Use index.files for context
}
```

## Limitations

As a temporary solution, the current index has these constraints:

1. **No semantic search**: Exact file path matching only
2. **Static descriptions**: Doesn't update automatically with code changes
3. **File-level granularity**: No function or class-level indexing
4. **Linear scanning**: Must iterate through all files to find relevant ones
5. **Description quality**: Limited to LLM's understanding from single file view

## Future: Vector-Based Index

The planned vector-based replacement will provide:

- **Semantic search**: Find files by meaning, not just keywords
- **Embedding-based retrieval**: Similar code patterns and concepts
- **Function-level indexing**: Understand individual functions and classes
- **Automatic updates**: Track file changes and incrementally update embeddings
- **Contextual understanding**: Cross-file relationships and dependencies
- **Efficient querying**: Sub-linear search complexity

## Performance

Current indexing performance (based on typical projects):

- **Small projects** (~50 files): 30-60 seconds
- **Medium projects** (~200 files): 2-4 minutes
- **Large projects** (~500 files): 5-10 minutes

Time varies based on:

- LLM API response times
- Rate limiting delays (500ms between files)
- File sizes and complexity

## Best Practices

1. **Run after major changes**: Keep the index synchronized with your codebase
2. **Commit the index**: Version control helps track project evolution
3. **Update incrementally**: Run `bluprint index src/` for specific directories when making focused changes
4. **Review descriptions**: Check generated descriptions for accuracy
5. **Exclude appropriately**: Add non-source files to `.gitignore` to avoid indexing them

## Troubleshooting

### Index file missing

**Error**: `Codebase index missing at .bluprint/codebase/semantic_index.json`

**Solution**: Run `bluprint index` to generate the index

### LLM errors during generation

**Issue**: API timeouts or rate limits

**Solution**: The indexer handles failures gracefully by returning empty descriptions for problematic files. Re-run to retry failed files.

### Incorrect descriptions

**Issue**: LLM misunderstands file purpose

**Solution**: This is expected with the simple approach. The vector-based index will improve accuracy through better context understanding.
